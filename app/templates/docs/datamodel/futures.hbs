<Layout::Text text-l text-f>
	<h5><i class="fas fa-arrow-left"></i> &nbsp; <Link @link="docs.datamodel.index">Back to overview</Link></h5>
    <h2>Futures</h2>
	<p>Futures are values which are only computed when the data is selected and returned to the client. Futures can be stored inside records, to enable dynamic values which are always calculated when queried.</p>
</Layout::Text>

<Layout::Gap small />

<Layout::Text text-l text-f>
	<h3>Simple futures</h3>
	<p>Any value or expression can be used inside a future. This value will be dynamically computed on every access to the record.</p>
	<Code @name="docs-datamodel-futures-simple.sql">
		CREATE person SET accessed_date = fn::future -> { time::now() };
	</Code>
</Layout::Text>

<Layout::Gap small />

<Layout::Text text-l text-f>
	<h3>Futures depending on other fields</h3>
	<p>Futures can be used to calculate values which dynamically change based on other fields. This value will be dynamically computed, on every access to the record, and will use the other field when it is accessed.</p>
	<Code @name="docs-datamodel-futures-dependent-1.sql">
		CREATE person SET
			birthday = "2007-06-22",
			can_drive = fn::future -> { time::now() > birthday + 18y }
		;
	</Code>
	<p>Futures can also dynamically access remote records, perform subqueries, or make use of graph traversal.</p>
	<Code @name="docs-datamodel-futures-dependent-2.sql">
		CREATE person SET
			name: 'Jason',
			friends = [person:tobie, person:jaime],
			adult_friends = fn::future -> { friends[WHERE age > 18].name }
		;
	</Code>
</Layout::Text>

<Layout::Gap small />

<Layout::Text text-l text-f>
	<h3>Next steps</h3>
	<p>You've now seen how to create dynamically computed properties on records, using either simple values, and values which depend on local and remote record fields. Take a look at the next chapter to understand how types can be cast and converted to other types.</p>
</Layout::Text>

<Layout::Gap large />